@using SpendLess.Web.Domain.SpendLess.Domain
@model SpendLess.Web.Domain.SpendLess.Domain.AutocompleteModel

@if(Model is AutocompleteSuggestionsModel suggestions)
{
    @foreach(var item in suggestions.Suggestions)
    {
        <a class="dropdown-item" _="on mousedown send selectionClicked(text:(my innerHTML)) to the previous .input">@item</a>
    }
}
else if(Model is AutocompleteBodyModel body)
{
    <div class="control autocomplete is-flex is-flex-direction-column">
        <input class="input" type="text" 
            @(body.Name.HasValue ? Html.Raw($"name=\"{body.Name.Value}\"") : "")
            @(body.Id.HasValue ? Html.Raw($"id=\"{body.Id.Value}\"") : "")
            @(body.Placeholder.HasValue ? Html.Raw($"placeholder=\"{body.Placeholder.Value}\"") : "")
            _="
                on input debounced at 200ms
                    send focus to me
                end
                on selectionClicked
                    set my value to event.detail.text
                    @(body.CompletionEvent.HasValue ? $"then send {body.CompletionEvent.Value}" : "")
                end
                on focus
                    add .is-active to the next .dropdown 
                    send update to the next .dropdown
                end
                on focusout
                    remove .is-active from the next .dropdown
                    set (the next .dropdown-content)'s innerHTML to ''
                end
                on keydown
                    if the event's key is 'Enter'
                        if (the next <.dropdown-item.is-active />) is not null
                            halt the event
                            set my value to (the next <.dropdown-item.is-active/>)'s innerHTML
                            send focusout to me
                            @(body.CompletionEvent.HasValue ? $"then send {body.CompletionEvent.Value}" : "")
                        end
                    end
                    if the event's key is 'ArrowDown'
                        halt the event
                        if (the next <.dropdown-item.is-active />) is null
                            if (the next <.dropdown-item />) is not null
                                add .is-active to the next .dropdown-item
                            end
                        else
                            if (the next <.dropdown-item.is-active + .dropdown-item/>) is not null
                                add .is-active to the next <.dropdown-item.is-active + .dropdown-item/>
                                remove .is-active from the next <.dropdown-item.is-active/>
                            end
                        end
                    end
                    if the event's key is 'ArrowUp'
                        halt the event
                        if (the next <.dropdown-item.is-active />) is not null
                            if (the next <.dropdown-item:has(+ .dropdown-item.is-active)/>) is not null
                                add .is-active to the next <.dropdown-item:has(+ .dropdown-item.is-active)/>
                                remove .is-active from the next <.dropdown-item.is-active + .dropdown-item.is-active/>
                            end
                        end
                    end
                end
            "/>
        <div 
            class="dropdown @(body.IsRight ? "is-right" : "")"
            hx-trigger="update" 
            hx-post="/_event/@Html.Raw(body.SuggestionEvent)" 
            hx-swap="innerHTML" 
            hx-include="@Html.Raw(body.HxIncludeString)"
            hx-target="find .dropdown-content">
            <div class="dropdown-menu">
                <div class="dropdown-content"></div>
            </div>
        </div>
    </div>
}
